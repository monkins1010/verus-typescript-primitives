/// <reference types="node" />
/// <reference types="bn.js" />
import { BigNumber } from '../utils/types/BigNumber';
import { SerializableEntity } from '../utils/types/SerializableEntity';
import { IdentityID } from './IdentityID';
import { KeyID } from './KeyID';
import { SaplingPaymentAddress } from './SaplingPaymentAddress';
import { PartialMMRData, PartialMMRDataJson, SingleKeyMMRData } from './PartialMMRData';
import { AllowedHashes } from '../constants/pbaas';
import { VdxfUniValue, VdxfUniValueJson } from './VdxfUniValue';
export declare type PartialSignDataInitData = {
    flags?: BigNumber;
    address?: IdentityID | KeyID;
    prefixstring?: Buffer;
    vdxfkeys?: Array<IdentityID>;
    vdxfkeynames?: Array<Buffer>;
    boundhashes?: Array<Buffer>;
    hashtype?: BigNumber;
    encrypttoaddress?: SaplingPaymentAddress;
    createmmr?: boolean;
    signature?: Buffer;
    datatype?: BigNumber;
    data?: Buffer | PartialMMRData | VdxfUniValue;
};
export declare type PartialSignDataJson = {
    flags?: string;
    address?: string;
    prefixstring?: string;
    vdxfkeys?: Array<string>;
    vdxfkeynames?: Array<string>;
    boundhashes?: Array<string>;
    hashtype?: string;
    encrypttoaddress?: string;
    createmmr?: boolean;
    signature?: string;
    datatype?: string;
    data?: string | PartialMMRDataJson | VdxfUniValueJson;
};
export declare type CLISignDataKey = "filename" | "message" | "messagehex" | "messagebase64" | "datahash" | "mmrdata" | "vdxfdata";
declare type AtLeastOne<T, U = {
    [K in keyof T]: Pick<T, K>;
}> = Partial<T> & U[keyof U];
declare type SignDataKeys = {
    filename?: string;
    message?: string;
    messagehex?: string;
    messagebase64?: string;
    datahash?: string;
    vdxfdata?: VdxfUniValueJson;
    mmrdata?: Array<SingleKeyMMRData | string>;
};
declare type BaseFields = {
    address?: string;
    prefixstring?: string;
    vdxfkeys?: Array<string>;
    vdxfkeynames?: Array<string>;
    boundhashes?: Array<string>;
    hashtype?: string;
    encrypttoaddress?: string;
    createmmr?: boolean;
    signature?: string;
    datatype?: string;
    data?: string;
};
declare type MMRFields = {
    mmrsalt?: Array<string>;
    mmrhashtype?: AllowedHashes;
    priormmr?: Array<string>;
};
export declare type PartialSignDataCLIJson = ((AtLeastOne<Omit<SignDataKeys, 'mmrdata'>> & BaseFields) | (AtLeastOne<SignDataKeys> & MMRFields & BaseFields));
export declare class PartialSignData implements SerializableEntity {
    flags: BigNumber;
    address?: IdentityID | KeyID;
    prefixstring?: Buffer;
    vdxfkeys?: Array<IdentityID>;
    vdxfkeynames?: Array<Buffer>;
    boundhashes?: Array<Buffer>;
    hashtype?: BigNumber;
    encrypttoaddress?: SaplingPaymentAddress;
    createmmr?: boolean;
    signature?: Buffer;
    datatype?: BigNumber;
    data?: Buffer | PartialMMRData | VdxfUniValue;
    static CONTAINS_DATA: import("bn.js");
    static CONTAINS_ADDRESS: import("bn.js");
    static CONTAINS_ENCRYPTTOADDRESS: import("bn.js");
    static CONTAINS_CURRENTSIG: import("bn.js");
    static CONTAINS_PREFIXSTRING: import("bn.js");
    static CONTAINS_VDXFKEYS: import("bn.js");
    static CONTAINS_VDXFKEYNAMES: import("bn.js");
    static CONTAINS_BOUNDHASHES: import("bn.js");
    constructor(data?: PartialSignDataInitData);
    protected containsData(): boolean;
    protected containsAddress(): boolean;
    protected containsEncrypttoAddress(): boolean;
    protected containsCurrentSig(): boolean;
    protected containsPrefixString(): boolean;
    protected containsVdxfKeys(): boolean;
    protected containsVdxfKeyNames(): boolean;
    protected containsBoundhashes(): boolean;
    private toggleContainsData;
    private toggleContainsAddress;
    private toggleContainsEncryptToAddress;
    private toggleContainsCurrentSig;
    private toggleContainsPrefixString;
    private toggleContainsVdxfKeys;
    private toggleContainsVdxfKeyNames;
    private toggleContainsBoundHashes;
    isMMRData(): boolean;
    isVdxfData(): boolean;
    private getPartialSignDataByteLength;
    getByteLength(): number;
    fromBuffer(buffer: Buffer, offset?: number): number;
    toBuffer(): Buffer;
    toJson(): PartialSignDataJson;
    static fromJson(json: PartialSignDataJson): PartialSignData;
    toCLIJson(): PartialSignDataCLIJson;
    static fromCLIJson(json: PartialSignDataCLIJson): PartialSignData;
}
export {};
